\documentclass[notitlepage, 12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % makes the angle brackets display properly
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{helvet}
\usepackage{wrapfig}
\usepackage{float}
\usepackage[export]{adjustbox}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{titling} % https://tex.stackexchange.com/questions/591/removing-vertical-space-inside-maketitle/593
\usepackage{authoraftertitle}
\usepackage{pythontex}
\usepackage{xltabular}
\renewcommand{\familydefault}{\sfdefault}

\graphicspath{{images/}}

\newcommand{\code}[1]{\texttt{#1}}

\title{Criterion C: Development}
\definecolor{msblue}{HTML}{5AB5D8}
\makeatletter

\begin{document}
% Title
\centerline{\textcolor{msblue}{
		\fontspec{Cambria}\textbf{\fontsize{13}{13}\MyTitle}
	}}
\bigskip

My timeblocker program is written using a client-server architecture. The client is a website frontend written using HTML, CSS, and TypeScript (a statically-typed superset of JavaScript). The server is a Node.js backend with a PostgreSQL database.

\section*{Frontend}
The frontend is a single-page application built with Vue, a JavaScript framework for building user interfaces. The files for the frontend are all contained within the `frontend/` folder.

\section*{Significant files/folders:}
\begin{xltabular}{\textwidth}{
		@{}
		p{0.3\textwidth}
		X
	}
	% https://tex.stackexchange.com/a/57709
	\centerline{\adjustbox{valign=t}{
			\includegraphics[width=0.3\textwidth]{frontend-files.png}
		}}
	 &
	\begin{itemize}[label={}, leftmargin=5pt]
		\item \textbf{public:} Assets that are hosted on the website as-is (e.g. the favicon).
		\item \textbf{src/:} The main website source code.
		      \begin{itemize}[label={}]
			      \item \textbf{classes/:} Frontendâ€™s OOP classes.
			      \item \textbf{components/:} Vue components.
			      \item \textbf{layouts/:} UI templates reused across multiple pages.
			      \item \textbf{pages/:} Website pages.
			      \item \textbf{store/:} Global data store.
			      \item \textbf{types/:} TypeScript types.
			      \item \textbf{utils/:} Various utility functions.
			      \item \textbf{app.vue:} Main Vue component.
			      \item \textbf{main.ts:} Entrypoint for website scripts.
			      \item \textbf{router.ts:} Website routing configuration.
			      \item \textbf{tailwind.css:} Loads TailwindCSS styles.
		      \end{itemize}
		\item \textbf{index.html:} Website entrypoint.
		\item \textbf{Configuration files (*.cjs, *.json, vite.config.ts):} Configuration files for various frontend development tools.
	\end{itemize}
\end{xltabular}
\section*{Development}
To develop my program, I used various build tools from the JavaScript ecosystem.
For the frontend, I used Vite, a build tool that uses a feature called ``Hot Module Reload'' that allows me to update the site without needing to refresh the page.

\section*{User Interface}
\begin{xltabular}{\textwidth}{
		@{}
		p{0.3\textwidth}
		X
	}
	\centerline{\adjustbox{valign=t}{
			\includegraphics[width=1\textwidth]{frontend-pages-folder.png}
		}}
	 &
	The code responsible for the user interface is stored under the src/pages folder.
	The \code{.vue} file extension indicates Vue Single-File Components, or SFCs for short.
	These files contain all the necessary HTML, CSS, and JavaScript to render a component part of a dynamic user interface.
\end{xltabular}

\vspace{10pt}

% https://tex.stackexchange.com/questions/205086/do-not-indent-a-tabular
\noindent\begin{xltabular}{\textwidth}{
		@{}
		X
		p{0.6\textwidth}
		@{}
	}
	In each Vue SFC, there are three root tags: the \code{<script>} tag, the \code{<template>} tag, and the \code{<style>} tag. The \code{<script>} tag contains the JavaScript/TypeScript code that is executed when the component is initialized for the first time. The \code{<template>} tag contains the HTML that defines the structure of the component, and the \code{<style>} tag contains the CSS that is used to style the component.
	 &
	\centerline{\adjustbox{valign=t}{
			\includegraphics[width=0.6\textwidth]{frontend-vue-sfc.png}
		}}
\end{xltabular}

Most of the SFCs don't contain a \code{<style>} tag because the CSS styles are primarily contained within the HTML using TailwindCSS's utility classes. TailwindCSS is a CSS framework that provides flexible utility classes for making it easier to style HTML. In addition, I used a Tailwind library known as daisyUI that provides out-of-the-box styled components for common HTML components.

\section*{Landing Page}
\includegraphics[width=\textwidth]{frontend-landing-page.png}

To build the landing page, I used Vue's \code{v-for} feature: instead of copy-pasting my HTML code three times and, I defined the information needed to render each feature in my JavaScript and used \code{v-for} to render multiple HTML elements:

\includegraphics[width=\textwidth]{landing-page-features.png}
\includegraphics[width=\textwidth]{landing-page-v-for.png}

In addition, I used an if statement for the functionality of the "Create Timeblock" button that dynamically redirects the user based on whether or not they are logged in to the site. If they are logged in, it brings the user to the "Timeblock" page, and otherwise to the "Register" page.
\includegraphics[width=0.3\textwidth]{landing-page-go-to-timeblock-page.png}

\section*{Register/Login Page}

\includegraphics[width=0.4\textwidth]{frontend-register-page.png}
\includegraphics[width=0.4\textwidth]{frontend-login-page.png}

The register and login page presents the user with a basic form that prompts them to enter their email and password. Even though they may look like two separate pages, I actually only used one file to create both these pages since they share a lot of code, and I decided whether to display the register or the login form based on the route (\code{/login} vs \code{/register}):

\includegraphics[width=0.4\textwidth]{frontend-entry-page-route.png}

The \code{\$computed} function is Vue-specific function that will automatically update the value of the variable \code{isLogin} whenever the \code{route} variable changes. This way, my page will automatically re-render the correct form whenever the user navigates from the login page to the register page and vice-versa.

\section*{Authentication}

Once a user clicks the Login button, the \code{login} function is called:

\includegraphics[width=0.4\textwidth]{frontend-login-function.png}

This function sets a variable \code{isRequestLoading} to true so that the loading spinner displays on the button. It then sends a request to the tRPC backend, which handles the \code{'login'} mutation by executing the following code on the backend:

\includegraphics[width=0.4\textwidth]{backend-login-function.png}

When a user creates an account, the backend saves the password as a one-way bcrypt hash. Two strings that are the same will always produce the same hash. This allows me to confidently check whether the password the user enters matches the account password. In addition, given a password hash, it is computationally infeasible to find the original password. This way, if the information in my database ever gets leaked, users' passwords will still be protected because the original password can't be feasibly recovered from the hash.

\section*{Timeblock Sidebar}

I sort the tasks using a recursive merge sort algorithm:

\includegraphics[width=1\textwidth]{merge-sort.png}

Once the

\section*{Timeblock Schedule}

To represent the different types of tasks (normal, fixed time, and fixed weekly time), I used inheritance by extending the base Task and TaskBlock classes:

\includegraphics[width=1\textwidth]{inheritance.png}

The FixedTimeTaskBlock class overrides the \code{getStartTime} and \code{getEndTime} methods of the base TaskBlock class. For the FixedTimeTaskBlock class, the start time and the end time are stored in the FixedTimeTask class that the task block is linked to, hence it returns the start time and end time of the task instead. By using inheritance and method overriding, I'm able to leverage polymorphism, as shown in the following code:

\includegraphics[width=1\textwidth]{polymorphism.png}

In the above code, I'm retrieving the task block using the Timeblock class method \code{getTaskBlock(taskBlockId)}. My code doesn't care which type of TaskBlock it is; the TaskBlock just needs to have a \code{getStartMinute} and \code{getEndMinute} function. When the task block is a FixedTimeTaskBlock, the \code{getStartMinute} and \code{getEndMinute} of the FixedTimeTaskBlock class will be called instead of the \code{getStartMinute} and \code{getEndMinute} of the base TaskBlock class.

\section*{Timeblock Column}


The task dock contains all the user's tasks, and the user has the option to add and delete tasks. The user can add a task by pressing on the ``Add Task'' button. The calendar contains all the ``task blocks,'' which represent chunks of time dedicated to a user's task. The user can toggle the task dock on and off by pressing the menu in the top left. To create a new task block, the user can drag one of their existing tasks onto the calendar. Then, a new task block will appear on the calendar that the user can resize or drag to a different time slot.

On the right side of the timeblock calendar, there is a plus icon that allows the user to add a new timeblock column. Timeblock columns are used for creating multiple versions of a timeblock, as it's common for users to experience interruptions in their day and need to recreate their timeblock.

\section*{Backend}
The backend uses tRPC, a TypeScript library for defining type-safe server routes, and Fastify, a low overhead web framework for Node.js. Significant files/folders include:

\noindent\begin{xltabular}{\textwidth}{
		@{}
		p{0.3\textwidth}
		X
	}
	\adjustbox{valign=t}{\includegraphics[width=0.3\textwidth]{backend-files.png}}
	 &
	\begin{itemize}[label={}, leftmargin=5pt]
		\item	\textbf{prisma/:} Database models and configuration files for the Prisma ORM.
		\item	\textbf{src/:} Main backend source code.
		\item	\textbf{bin/:} Scripts that should be executed to start the server.
		\item	\textbf{routes/:} tRPC route definitions.
		\item	\textbf{types/:} TypeScript types.
		\item	\textbf{utils/:} Various utility functions.
		\item	\textbf{.env:} Environment secrets (should not be public!)
		\item	\textbf{Configuration files (*.cjs, *.json):} Configuration files for various backend development tools.
	\end{itemize}
\end{xltabular}

\section*{Database Models}
\includegraphics[width=1\textwidth]{backend-database-models.png}

\section*{tRPC Routes}
\includegraphics[width=1\textwidth]{backend-trpc-routes.png}

\def\arraystretch{1.3}
\section*{Solution Mastery Aspect}
\textbf{IB Standard Level}
\vspace{-6pt}
\noindent\begin{xltabular}{\textwidth}{|p{0.3\textwidth\RaggedRight}|X|}
	\hline
	\textbf{Mastery Factor}
	& \textbf{Where it would be used}
	\\\hline
	1. Arrays
	& Array of tasks in the schedule
	\\\hline
	2. User-defined objects
	& A list of task boxes
	\\\hline
	3. Objects as data records
	& Task box details (title, description, etc.)
	\\\hline
	4. Simple selection (if-else)
	& When the user creates a task, an if statement is used to check if the task name is empty, and if so, cancels creating the task (since a task's name can't be empty).
	\\\hline
	5. Complex selection (nested if, if with multiple conditions or switch)
	& When the user has selected the type of task to create, I use a switch statement when initializing the correct class instance for the type of task the user is creating.
	\\\hline
	6. Loops
	& Looping through all the task blocks that need to be created on the client-side when the list of the user's task blocks are returned from the server.
	\\\hline
	7. User-defined methods
	& The onDrop method that gets called whenever a user drops a task onto the schedule.
	\\\hline
	8. User-defined methods with appropriate return values
	& A method that returns the color based on the type of task so that the different types of tasks are colour-coded.
	\\\hline
	9. Sorting
	& Sorting of task boxes in the preview based on the task names.
	\\\hline
	10. Searching
	& Searching through task boxes based on the name/description.
	\\\hline
	11. Use of additional libraries
	& I will be using various industry-standard frontend and backend development tools and libraries for making development easier. The main ones are Vue.js (a JavaScript framework for building user interfaces) for the frontend, and Fastify (a fast Node.js web framework) for the backend. See Appendix for a complete list of third-party libraries used in Timeblocker.
	\\\hline
\end{xltabular}

\bigskip

\noindent\textbf{IB Higher Level}
\smallskip

\def\arraystretch{1.5}
\noindent\begin{xltabular}{\textwidth}{|l|X|}
	\hline
	\textbf{Mastery Factor}
	& \textbf{Where it would be used}
	\\\hline
	1. Polymorphism
	& The different types of task blocks and task boxes will have the same method signatures but have different functionality, and I use polymorphism to invoke the unique functionality of each task block.
	\\\hline
	2. Inheritance
	& Specific types of tasks and task blocks (fixed weekly task and fixed weekly time tasks) inherit from the Task and TaskBlock base classes.
	\\\hline
	3. Encapsulation
	& The classes will only expose getters and setters that retrieve private properties on classes. The setters will validate the input to make sure that the new value set on the class instance is valid.
	\\\hline
	4. Database
	& Timeblocker will be using PostgreSQL as the database, using Prisma as the ORM for type-safety with TypeScript.
	\\\hline
\end{xltabular}

\end{document}
