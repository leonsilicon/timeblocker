\documentclass[12pt, notitlepage]{article}
\usepackage[margin=1in]{geometry}
\usepackage{tabularx}
\usepackage{xltabular}
\usepackage{xcolor}
\usepackage{fontspec}
\usepackage{ragged2e}
\usepackage{bashful}
\usepackage{shellesc}
\usepackage{authoraftertitle}
\usepackage{hyperref}
\usepackage{pythontex}

\setpythontexcontext{jobname=\jobname}

% \begin{noindent}
\begin{pycode}
import subprocess
from shlex import split
def word_count(thesection):
	result = subprocess.run(split(f"""texcount -sub=section {pytex.context.jobname}.tex | grep "Section" | sed -e 's/+.*//' | sed -n "{thesection}" p"""), shell=True)
	return f"Word count: {result.stdout}words"
\end{pycode}
% \end{noindent}

\newcommand\wordcount[2]{%
\py{word_count(#1, #2)}
\noindent Word count: \input{count.txt}words
}

\title{Criterion A: Planning}
\definecolor{msblue}{HTML}{5AB5D8}
\makeatletter

\begin{document}
\centerline{\textcolor{msblue}{
		\fontspec{Cambria}\textbf{\fontsize{13}{13}\MyTitle}
	}}

\noindent\textbf{Client:} Leon Si (myself)
\\
\textbf{Advisor:} Mark Si (my dad)

\section{Problem Description}
Many people, especially students like me, have many tasks they need to finish in a day.
However, an unstructured daily plan can be inefficient: that's where Timeblocking comes in.
Timeblocking is a strategy where you dedicate chunks of time in your day to work on specific tasksâ€”I use timeblocking in my daily life to help keep my tasks under control.
While timeblocking is a powerful strategy, implementing
there's no online program focused on timeblocking: current solutions like Google Calendar make this process difficult and time-consuming.
These apps don't have features that are essential for timeblocking, like an easy way to create a copy of a schedule to resize it
Initially, I considered building a plugin for these apps that would add the additional features, but I eventually learned that they don't expose the necessary functionality for me to fully customize the calendar view.
Thus, I want to create an app from scratch that allows me (and other students!) to easily create a timeblocking schedule that will sync between multiple devices.

\bigskip
\py{word_count()}

\section{Proposed Solution}
My app, Timeblocker, will provide an interface that allows students to add tasks to a daily timeblocking schedule.
My app will contain two parts: task boxes and a schedule. The boxes will represent tasks, and the user will be able to drag the boxes onto the schedule, where they'll be able to resize the boxes to fit the time on the schedule during when they would like to work on it. The user can create and reuse task blocks, so that they don't need to create a separate event each time.

Each task block will have a title (the name of the task), a description, and extra information based on the box type.
There will be multiple types of boxes, such as a school based box, an entertainment box, etc.
Thus, this will need the use of inheritance (SchoolTaskBox extends TaskBox).

The app will also allow the user the ability to import and export their schedules as a file.
In addition, users will have the ability to create an account to synchronize their schedules across different computers.

I'm building this app in TypeScript (a superset of JavaScript that compiles to JavaScript) because I want this app to be as accessible as possible.
Since TypeScript compiles to JavaScript, a programming language that all browser support, users will be able to access my app from any device with a browser:
all they need to do is visit the website \href{https://ib.timeblocker.io}{timeblocker.io}\footnote{For my IB submission, I'm deploying the site under the URL https://ib.timeblocker.io in case I wish to make changes to the original domain. I'll also be including a pre-built version of the website in the code linked to the title page as well.}.
In addition, I'll also be building the server in TypeScript:
by building the frontend and backend in the same language, I'll be able to share code between the frontend and backend which enables me to use powerful libraries like tRPC that automatically read the backend's routes to create type-safe functions.
I decided to use TypeScript instead of plain JavaScript because TypeScript's strongly-typed guarantees help eliminate many type errors at compile-time (e.g., typos, passing wrong types to functions, calling non-existent class methods).

\bigskip
\wordcount

\section{Success Criteria}
\begin{itemize}
	\item Create, edit, and delete tasks
	\item Drag tasks onto the schedule to create task blocks
	\item Creating multiple timeblocks
	\item Searching through task boxes
	\item Resizing the task boxes that are on the schedule
	\item Changing the schedule view between day and week
	\item Registering and logging into accounts
	\item Server-side synchronization with a database to access schedules across devices
	\item Exporting the timeblock as a file
	\item Schedule autosaves every time changes are made
\end{itemize}

\section{Target Market}
The target market of this software is people that are looking to schedule their day in a way that saves them time and helps them get more done in a day.

\section{Solution Mastery Aspect}
\textbf{IB Standard Level}
\vspace{-6pt}
\noindent\begin{xltabular}{\textwidth}{|p{0.3\textwidth\RaggedRight}|X|}
	\hline
	\textbf{Mastery Factor}
	& \textbf{Where it would be used}
	\\\hline
	1. Arrays
	& Array of tasks in the schedule
	\\\hline
	2. User-defined objects
	& A list of task boxes
	\\\hline
	3. Objects as data records
	& Task box details (title, description, etc.)
	\\\hline
	4. Simple selection (if-else)
	& When the user drops the task onto the schedule, the program checks if the task is overlapping an existing task on the schedule so that it can move the task either before or after.
	\\\hline
	5. Complex selection (nested if, if with multiple conditions or switch)
	& In more complex scenarios, like dragging and dropping a task box between two tasks, the program needs to determine the most likely placement where the user wants to put the new task depending on where it is dropped.
	\\\hline
	6. Loops
	& Looping through all the task boxes when the user exports the schedule.
	\\\hline
	7. User-defined methods
	& An "export" and "import" method that imports a schedule from a file.
	\\\hline
	8. User-defined methods with appropriate return values
	& A method to validate a user-supplied file to check if it's valid to import.
	\\\hline
	9. Sorting
	& Sorting of task boxes in the preview based on name.
	\\\hline
	10. Searching
	& Searching through task boxes based on the name/description.
	\\\hline
	11. File I/O
	& Ability for the user to import and export files into the program.
	\\\hline
	12. Use of additional libraries
	& I will be using various industry-standard frontend and backend development tools and libraries for making development easier. The main ones are Vue.js (a JavaScript framework for building user interfaces) for the frontend, and Fastify (a fast Node.js web framework) for the backend. See Appendix for a complete list of third-party libraries used in Timeblocker.
	\\\hline
\end{xltabular}

\bigskip

\noindent\textbf{IB Higher Level}
\smallskip

\noindent\begin{tabularx}{\textwidth}{|l|X|}
	\hline
	\textbf{Mastery Factor}
	 & \textbf{Where it would be used}
	\\\hline
	1. Polymorphism
	 & Each box will have a function that displays itself in a certain way, but the way the box displays itself is based on the box type and thus requires polymorphism.
	\\\hline
	2. Inheritance
	 & Specific task boxes (SchoolTaskBox inherits from TaskBox).
	\\\hline
	3. Encapsulation
	 & The classes that will make use of private variables and getters/setters to modify/access those variables.
	\\\hline
	4. Database
	 & Timeboxer will be using PostgreSQL as the database, using Prisma as the ORM for type-safety with TypeScript.
	\\\hline
\end{tabularx}
\end{document}